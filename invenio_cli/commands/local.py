# -*- coding: utf-8 -*-
#
# Copyright (C) 2020 CERN.
# Copyright (C) 2022-2024 Graz University of Technology.
#
# Invenio-Cli is free software; you can redistribute it and/or modify it
# under the terms of the MIT License; see LICENSE file for more details.

"""Invenio module to ease the creation and management of applications."""

import os
import signal
from distutils.dir_util import copy_tree
from os import environ

# from os.path import join
from pathlib import Path
from subprocess import Popen as popen

import click

from ..helpers import filesystem  # env,
from ..helpers.process import ProcessResponse  # , run_interactive
from .commands import Commands

# from flask.helpers import get_root_path


# from flask_webpackext import WebpackBundleProject


# from flask_webpackext.project import WebpackBundleProject


# from pywebpack import WebpackBundleProject as PyWebpackBundleProject
# from pywebpack import bundles_from_entry_point
# from werkzeug.utils import import_string


# def flask_config(app, project):
#     """Flask configuration injected in Webpack.

#     :return: Dictionary which contains the information Flask-WebpackExt knows
#         about a Webpack project and the absolute URLs for static files and
#         assets. The dictionary consists of a key ``build`` with the following
#         keys inside:

#         * ``debug``: Boolean which represents if Flask debug is on.
#         * ``context``: Absolute path to the generated assets directory.
#         * ``assetsPath``: Absolute path to the generated static directory.
#         * ``assetsURL``: URL to access the built files.
#         * ``staticPath``: Absolute path to the generated static directory.
#         * ``staticURL``: URL to access the static files..
#     """
#     assets_url = app.config["WEBPACKEXT_PROJECT_DISTURL"]
#     if not assets_url.endswith("/"):
#         assets_url += "/"
#     static_url = app.static_url_path
#     if not static_url.endswith("/"):
#         static_url += "/"

#     k = {
#         "build": {
#             "debug": app.debug,
#             "context": "/home/christoph/work/tests/repos/master/rspack/.venv/var/instance/assets",
#             "assetsPath": app.config["WEBPACKEXT_PROJECT_DISTDIR"],
#             "assetsURL": assets_url,
#             "staticPath": app.static_folder,
#             "staticURL": static_url,
#         }
#     }
#     print(f"local.py flask_config k: {k}")

#     return k


# class _PathStorageMixin(object):
#     """Mixin class."""

#     @property
#     def path(self):
#         """Get path to project."""
#         return self.app.config["WEBPACKEXT_PROJECT_BUILDDIR"]

#     @property
#     def storage_cls(self):
#         """Get storage class."""
#         cls_ = self.app.config["WEBPACKEXT_STORAGE_CLS"]
#         if isinstance(cls_, str):
#             return import_string(cls_)
#         return cls_


# class WebpackBundleProject(_PathStorageMixin, PyWebpackBundleProject):
#     """Flask webpack bundle project."""

#     def __init__(
#         self,
#         import_name,
#         project_folder=None,
#         bundles=None,
#         config=None,
#         config_path=None,
#         app=None,
#     ):
#         """Initialize templated folder.

#         :param import_name: Name of the module where the WebpackBundleProject
#             class is instantiated. It is used to determine the absolute path
#             to the ``project_folder``.
#         :param project_folder: Relative path to the Webpack project which is
#             going to aggregate all the ``bundles``.
#         :param bundles: List of
#             :class:`flask_webpackext.bundle.WebpackBundle`. This list can be
#             statically defined if the bundles are known before hand, or
#             dinamically generated using
#             :func:`pywebpack.helpers.bundles_from_entry_point` so the bundles
#             are discovered from the defined Webpack entrypoints exposed by
#             other modules.
#         :param config: Dictionary which overrides the ``config.json`` file
#             generated by Flask-WebpackExt. Use carefuly and only if you know
#             what you are doing since ``config.json`` is the file that holds the
#             key information to integrate Flask with Webpack.
#         :param config_path: Path where Flask-WebpackExt is going to write the
#             ``config.json``, this file is generated by
#             :func:`flask_webpackext.project.flask_config`.
#         """
#         self.app = app
#         # project_template_dir = join(get_root_path(import_name), project_folder)
#         project_template_dir = "/home/christoph/work/opensource/github/utnapischtim/invenio-assets/invenio_assets/assets"
#         config = flask_config(self.app, self)
#         super(WebpackBundleProject, self).__init__(
#             None,
#             project_template_dir=project_template_dir,
#             bundles=bundles,
#             config=config,
#             config_path=config_path,
#         )


class LocalCommands(Commands):
    """Local CLI commands."""

    def __init__(self, cli_config):
        """Constructor."""
        super().__init__(cli_config)

    def _symlink_assets_templates(self):
        """Symlink the assets folder."""
        files_to_link = self._copied_files
        assets = "assets"
        click.secho("Symlinking {}...".format(assets), fg="green")

        instance_path = self.cli_config.get_instance_path()
        project_dir = self.cli_config.get_project_dir()
        for file_path in files_to_link:
            file_path = Path(file_path)
            relative_path = file_path.relative_to(instance_path)
            target_path = project_dir / relative_path
            filesystem.force_symlink(target_path, file_path)

    def _copy_statics_and_assets(self):
        """Copy project's statics and assets into instance dir."""
        click.secho("Copying project statics and assets...", fg="green")

        # static and assets folders do not exist in non-RDM contexts
        rdm_static_dir_exists = os.path.exists("static")
        rdm_assets_dir_exists = os.path.exists("assets")

        if rdm_static_dir_exists:
            static = "static"
            src_dir = self.cli_config.get_project_dir() / static
            src_dir = str(src_dir)  # copy_tree below doesn't accept Path objects
            dst_dir = self.cli_config.get_instance_path() / static
            dst_dir = str(dst_dir)
            # using it for a different purpose then intended but very useful
            copy_tree(src_dir, dst_dir)

        if rdm_assets_dir_exists:
            assets = "assets"
            src_dir = self.cli_config.get_project_dir() / assets
            src_dir = str(src_dir)
            dst_dir = self.cli_config.get_instance_path() / assets
            dst_dir = str(dst_dir)
            # The full path to the files that were copied is returned
            self._copied_files = copy_tree(src_dir, dst_dir)
        self._copied_files = []

    def _statics(self):
        # Symlink the instance's statics and assets
        copied_files = self._copy_statics_and_assets()
        self._symlink_assets_templates(copied_files)
        return ProcessResponse(
            output="Assets and statics updated.",
            status_code=0,
        )

    def update_statics_and_assets(self, force, flask_env="production", log_file=None):
        """High-level command to update less/js/images/... files.

        Needed here (parent) because is used by Assets and Install commands.
        """
        # Commands
        # prefix = ["pipenv", "run", "invenio"]

        # ops = [prefix + ["collect", "--verbose"]]

        # if force:
        #     ops.append(prefix + ["webpack", "clean", "create"])
        #     ops.append(prefix + ["webpack", "install"])
        # else:
        #     ops.append(prefix + ["webpack", "create"])
        # ops.append(self._statics)
        # ops.append(prefix + ["webpack", "build"])
        # # Keep the same messages for some of the operations for backward compatibility
        # messages = {
        #     "build": "Building assets...",
        #     "install": "Installing JS dependencies...",
        # }

        # with env(FLASK_ENV=flask_env):
        #     for op in ops:
        #         if callable(op):
        #             response = op()
        #         else:
        #             if op[-1] in messages:
        #                 click.secho(messages[op[-1]], fg="green")
        #             response = run_interactive(
        #                 op, env={"PIPENV_VERBOSITY": "-1"}, log_file=log_file
        #             )
        #         if response.status_code != 0:
        #             break
        # return response
        import time
        import timeit

        from flask_collect import Collect
        from invenio_app.factory import create_cli
        from invenio_assets.webpack import project

        t0 = time.time()
        app = create_cli()
        t1 = time.time()
        create_cli_time = t1 - t0

        t0 = time.time()
        collect = Collect(app)
        t1 = time.time()
        collect_time = t1 - t0

        t0 = time.time()
        # project = WebpackBundleProject(
        #     __name__,
        #     project_folder="assets",
        #     config_path="build/config.json",
        #     bundles=bundles_from_entry_point("invenio_assets.webpack"),
        #     app=app,
        # )
        project.app = app
        t1 = time.time()
        project_time = t1 - t0

        collect_time = timeit.timeit(lambda: collect.collect(verbose=True), number=1)

        clean_time = timeit.timeit(lambda: project.clean(), number=1)
        create_time = timeit.timeit(lambda: project.create(), number=1)
        install_time = timeit.timeit(lambda: project.install(), number=1)

        # copied_files = self._copy_statics_and_assets()
        # self._symlink_assets_templates(copied_files)
        copy_time = timeit.timeit(lambda: self._copy_statics_and_assets(), number=1)
        symlink_time = timeit.timeit(lambda: self._symlink_assets_templates(), number=1)
        build_time = timeit.timeit(lambda: project.build(), number=1)
        print(
            f"LocalCommands.update_statics_and_assets\n create_cli_time: {create_cli_time}\n collect_time: {collect_time}\n project_time: {project_time}\n collect_time: {collect_time}\n clean_time: {clean_time}\n create_time: {create_time}\n install_time: {install_time}\n copy_time: {copy_time}\n symlink_time: {symlink_time}\n build_time: {build_time}\n "
        )

    def run(self, host, port, debug=True, services=True, celery_log_file=None):
        """Run development server and celery queue."""

        def signal_handler(sig, frame):
            click.secho("Stopping server and worker...", fg="green")
            server.terminate()
            if services:
                worker.terminate()
            click.secho("Server and worker stopped...", fg="green")

        signal.signal(signal.SIGINT, signal_handler)

        if services:
            click.secho("Starting celery worker...", fg="green")

            celery_command = [
                "pipenv",
                "run",
                "celery",
                "--app",
                "invenio_app.celery",
                "worker",
                "--beat",
                "--events",
                "--loglevel",
                "INFO",
                "--queues",
                "celery,low",
            ]

            if celery_log_file:
                celery_command += [
                    "--logfile",
                    celery_log_file,
                ]

            worker = popen(celery_command)

        click.secho("Starting up local (development) server...", fg="green")
        run_env = environ.copy()
        run_env["FLASK_ENV"] = "development" if debug else "production"
        run_env["INVENIO_SITE_UI_URL"] = f"https://{host}:{port}"
        run_env["INVENIO_SITE_API_URL"] = f"https://{host}:{port}/api"
        server = popen(
            [
                "pipenv",
                "run",
                "invenio",
                "run",
                "--cert",
                "docker/nginx/test.crt",
                "--key",
                "docker/nginx/test.key",
                "--host",
                host,
                "--port",
                port,
                "--extra-files",
                "invenio.cfg",
            ],
            env=run_env,
        )

        click.secho(f"Instance running!\nVisit https://{host}:{port}", fg="green")
        server.wait()
